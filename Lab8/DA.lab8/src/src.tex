\section{Описание}
Требуется написать реализацию топологической сортировки.

\vspace{\baselineskip}

{\bfseries В общем случае} задача на топологическую сортировку выглядит так: 

\vspace{\baselineskip}
"Дан ориентированный граф с n вершинами и m рёбрами. Требуется {\bfseries перенумеровать} его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим.

Иными словами, требуется найти перестановку вершин ({\bfseries топологический порядок}), соответствующую порядку, задаваемому всеми рёбрами графа.

Топологическая сортировка может быть {\bfseries не единственной} (например, если граф — пустой; или если есть три такие вершины $a, b, c$, что из $a$ есть пути в $b$ и в $c$, но ни из $b$ в $c$, ни из $c$ в $b$ добраться нельзя).

Топологической сортировки может {\bfseries не существовать вовсе} — если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот)." \cite{e-maxx}

\vspace{\baselineskip}
{\bfseries В нашем случае} заданы n объектов, и m отношений между ними — что один объект стоит впереди другого (или же, по аналогии с числами, одна вершина имеет меньший номер). Требуется проверить, не противоречивы ли эти отношения, и если нет, выдать объекты в порядке их "возрастания" (если решений несколько — выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из n вершин.

\vspace{\baselineskip}

Для топологической сортировки используется обход в глубину.

"Предположим, что граф ацикличен, т.е. решение существует. Что делает обход в глубину? При запуске из какой-то вершины $v$ он пытается запуститься вдоль всех рёбер, исходящих из $v$. Вдоль тех рёбер, концы которых уже были посещены ранее, он не проходит, а вдоль всех остальных — проходит и вызывает себя от их концов.

Таким образом, к моменту выхода из вызова {\rm dfs}($v$) все вершины, достижимые из $v$ как непосредственно (по одному ребру), так и косвенно (по пути) — все такие вершины уже посещены обходом. Следовательно, если мы будем в момент выхода из {\rm dfs}($v$) добавлять нашу вершину в начало некоего списка, то в конце концов в этом списке получится топологическая сортировка." \cite{e-maxx} И остаётся лишь сделать реверс этого списка.

\vspace{\baselineskip}
Чтобы топологическая сортировка существовала, нужно проверить граф на надичие циклов. Это можно сделать с помощью обхода в глубину \cite{circle}. Для этого непосещённые вершины красим в белый цвет, посещенные в чёрный, а вершины, из которых ещё может быть продолжен обход в глубину, серым. Если при обходе мы встретим серую вершину, то в графе присутсятвует цикл.

\vspace{\baselineskip}
Подход топологической сортировки использует идею жадного алгоритма: мы не перебираем все возможные варианты перестановок даже между элементами на одинаковой глубине. Оптимальный выбор запоминать самые глубокие вершины, а затем менее глубокие, даёт оптимальное решение задачи в целом.

\pagebreak

\section{Исходный код}

\vspace{\baselineskip}

\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

void DFS(int v, const vector<vector<int>>& G, vector<bool>& used, vector<int>& res) {
    
    used[v] = 1;
    for (int to: G[v]) {
        if (!used[to]) {
            DFS(to, G, used, res);
        }
    }
    res.push_back(v);
}

bool Circle(int v, const vector<vector<int>>& G, vector<string>& color) {
    color[v] = "grey";             
    for (int to: G[v]) {
        if (color[to] == "white")
            Circle(to, G, color);
        if (color[to] == "grey")
            return false;
    }  
    color[v] = "black";  
    return true;
}

int main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, m;
    cin >> n >> m;

    int a, b;
    vector<vector<int>> G(n);
    for (int i = 0; i < m; ++i) {
        cin >> a >> b;
        a--;
        b--;
        G[a].push_back(b);
    }

    
    vector<string> color(n, "white");
    for (int i = 0; i < n; ++i) {
        if(!Circle(i, G, color)) {
            cout << "-1\n";
            return 0;
        }
    }

    vector<bool> used(n);
    vector<int> res;
    for (int i = 0; i < n; ++i) {
        if (!used[i]) {
            DFS(i, G, used, res);
        }
    }

    reverse (res.begin(), res.end());

    for (size_t i = 0; i < res.size() - 1; ++i) {
        cout << res[i] + 1 << " " << res[i + 1] + 1 << "\n";       
    }

    return 0;
}
\end{lstlisting}

\vspace{\baselineskip}

\pagebreak

\section{Консоль}
\begin{alltt}
parsifal@DESKTOP-3G70RV4:~/DA/Lab8\$ g++ 1.cpp -o Lab8
parsifal@DESKTOP-3G70RV4:~/DA/Lab8\$ cat test.txt 
5 4
1 2
2 3
1 3
4 5
parsifal@DESKTOP-3G70RV4:~/DA/Lab8\$ ./Lab8 < test.txt 
4 5
5 1
1 2
2 3
parsifal@DESKTOP-3G70RV4:~/DA/Lab8\$ cat test1.txt 
3 3
1 2
2 3
3 1
parsifal@DESKTOP-3G70RV4:~/DA/Lab8\$ ./Lab8 < test1.txt 
-1
\end{alltt}
\pagebreak
